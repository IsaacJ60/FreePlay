const { ipcMain, app } = require("electron/main");
const fs = require("fs");
const path = require("path");
const fetch = require("isomorphic-unfetch");
const { getData, getPreview } = require("spotify-url-info")(fetch);
const ytdlp = require("youtube-dl-exec");
const Song = require("./models/Song.js");
const { spawn } = require("child_process");

function enhanceAudio(filePath) {
    return new Promise((resolve, reject) => {
        const pythonProcess = spawn("python", [
            path.join(__dirname, "enhancer.py"),
            filePath,
        ]);

        pythonProcess.stdout.on("data", (data) => {
            console.log(`Python stdout: ${data}`);
        });

        pythonProcess.stderr.on("data", (data) => {
            console.error(`Python stderr: ${data}`);
        });

        pythonProcess.on("close", (code) => {
            if (code === 0) {
                console.log(`Enhancement successful for ${filePath}`);
                resolve();
            } else {
                console.error(
                    `Enhancement failed for ${filePath} with code ${code}`
                );
                reject(new Error(`Python process exited with code ${code}`));
            }
        });
    });
}

function sanitize(filename) {
    // Remove illegal characters and any other characters that are not standard letters, numbers, or basic punctuation.
    return filename
        .replace(/[\\/:*?"<>|,]/g, "")
        .replace(/[^a-zA-Z0-9 ._-]/g, "");
}

function calculateScore(video, spotifyTrack) {
    let score = 0;
    const videoTitle = video.title.toLowerCase();
    const spotifyTitle = spotifyTrack.title.toLowerCase();
    const spotifyArtist = spotifyTrack.artist.toLowerCase();

    // +10 points if title includes song title
    if (videoTitle.includes(spotifyTitle)) {
        score += 10;
    } else {
        score -= 20;
    }

    // +10 points if title includes artist
    if (videoTitle.includes(spotifyArtist)) {
        score += 10;
    } else {
        score -= 15;
    }

    // +10 points for "official audio"
    if (videoTitle.includes("official audio")) {
        score += 10;
    }

    // +5 points for "official video"
    if (videoTitle.includes("official video")) {
        score += 5;
    }

    // +5 points for "topic" in channel name (often auto-generated by YouTube)
    if (video.channel && video.channel.toLowerCase().includes("topic")) {
        score += 20;
    }

    // +5 points for "lyrics"
    if (videoTitle.includes("lyrics") || videoTitle.includes("lyric video")) {
        score += 5;
    }

    // If Spotify title has "remix", we want a remix. Otherwise, we don't.
    if (spotifyTitle.includes("remix")) {
        if (videoTitle.includes("remix")) {
            score += 20;
        }
    } else {
        if (videoTitle.includes("remix")) {
            score -= 20;
        }
    }

    if (spotifyTitle.includes("lofi") || spotifyArtist.includes("lofi")) {
        if (videoTitle.includes("lofi")) {
            score += 20;
        }
    } else {
        if (videoTitle.includes("lofi")) {
            score -= 20;
        }
    }

    // If Spotify title has "cover", we want a cover. Otherwise, we don't.
    if (spotifyTitle.includes("cover")) {
        if (videoTitle.includes("cover")) {
            score += 20;
        }
    } else {
        if (videoTitle.includes("cover")) {
            score -= 20;
        }
    }

    if (spotifyTitle.includes("slowed")) {
        if (videoTitle.includes("slowed")) {
            score += 20;
        }
    } else {
        if (videoTitle.includes("slowed")) {
            score -= 20;
        }
    }

    if (spotifyTitle.includes("remix")) {
        if (videoTitle.includes("remix")) {
            score += 20;
        }
    } else {
        if (videoTitle.includes("remix")) {
            score -= 20;
        }
    }

    if (spotifyTitle.includes("acoustic")) {
        if (videoTitle.includes("acoustic")) {
            score += 10;
        }
    } else {
        if (videoTitle.includes("acoustic")) {
            score -= 10;
        }
    }

    if (spotifyTitle.includes("live")) {
        if (videoTitle.includes("live")) {
            score += 10;
        }
    } else {
        if (videoTitle.includes("live")) {
            score -= 10;
        }
    }

    // Score based on duration difference
    const durationDifference = Math.abs(
        video.duration * 1000 - spotifyTrack.duration
    ); // video.duration is in seconds
    if (durationDifference < 2000) {
        // Less than 2 seconds difference
        score += 20;
    } else if (durationDifference < 5000) {
        // Less than 5 seconds difference
        score += 10;
    }

    return score;
}

function registerSpotifyHandlers() {
    ipcMain.on("download-spotify-playlist", async (event, url) => {
        console.log(`[Spotify] Received request to download playlist: ${url}`);
        try {
            const data = await getData(url);
            if (!data) {
                console.error("[Spotify] ERROR: Could not fetch playlist data, it may be private or invalid.");
                event.sender.send("playlist-load-error");
                return;
            }

            console.log(`[Spotify] Successfully fetched data for playlist: "${data.name}"`);

            const playlistsDir = path.join(
                app.getPath("userData"),
                "playlists"
            );
            if (!fs.existsSync(playlistsDir)) {
                fs.mkdirSync(playlistsDir, { recursive: true });
            }

            const playlistName = sanitize(data.name);
            const savePath = path.join(playlistsDir, playlistName);
            if (!fs.existsSync(savePath)) {
                fs.mkdirSync(savePath, { recursive: true });
            }

            event.sender.send("playlist-start-load", {
                name: data.name,
            });

            console.log(`[Spotify] Downloading ${data.trackList.length} songs to "${savePath}"`);

            const songPromises = data.trackList.map(item => 
                downloadSpotifySong(item, savePath)
            );
            const resolvedSongs = await Promise.all(songPromises);
            const songList = resolvedSongs.filter(song => song); // Filter out any undefined results

            console.log(`[Spotify] Download complete. Successfully downloaded ${songList.length} of ${data.trackList.length} songs.`);

            event.sender.send("playlist-folder-ready", {
                name: data.name,
                path: savePath,
                tracks: songList,
            });
        } catch (e) {
            console.error("[Spotify] ERROR: An unexpected error occurred during playlist download:", e);

            let message = "Failed to download the playlist.";
            if (
                e?.message?.includes("Couldn't find any data") ||
                e?.html?.includes("Page not found")
            ) {
                message =
                    "The playlist could not be loaded. Please make sure it is public.";
            }

            event.sender.send("playlist-load-error", {
                error: message,
            });
        }
    });

    ipcMain.handle("download-spotify-song", async (event, url, visiblePlaylistPath) => {
        console.log(`[Spotify] Received request to download song: ${url}`);
        const data = await getData(url);
        const song = await downloadSpotifySong(data, visiblePlaylistPath);
        return song;
    });
}

async function downloadSpotifySong(item, savePath) {
    const trackTitleForLogging = item.title || item.name || 'Unknown Track';
    console.log(`[Spotify] Starting download for: "${trackTitleForLogging}"`);

    const songUrl =
        "https://open.spotify.com/track/" +
        item.uri.replace("spotify:track:", "");
    let songData;

    try {
        songData = await getPreview(songUrl);
    } catch (error) {
        console.error(`[Spotify] ERROR: Failed to fetch Spotify preview for "${trackTitleForLogging}".`, error);
        return;
    }

    if (!songData || !songData.title) {
        console.error(`[Spotify] ERROR: Invalid or empty Spotify preview data for "${trackTitleForLogging}". Skipping.`);
        return;
    }

    const title = `${songData.title} - ${songData.artist}`;
    const searchQuery = `${songData.title} ${songData.artist}`;
    const outputPath = path.join(
        savePath,
        `${sanitize(title)}.wav`
    );

    try {
        const spotifyTrack = {
            title: songData.title,
            artist: songData.artist,
            duration: songData.duration, // in milliseconds
        };

        let modifier = "";

        if (
            spotifyTrack.title.toLowerCase().includes("lofi") ||
            spotifyTrack.artist.toLowerCase().includes("lofi") ||
            spotifyTrack.title.toLowerCase().includes("version") ||
            spotifyTrack.title.toLowerCase().includes("remix")
        ) {
            modifier = "";
        } else {
            modifier = " Official Audio";
        }

        const searchResults = await ytdlp.exec(
            `ytsearch3:${searchQuery}${modifier}`,
            {
                dumpJson: true,
                defaultSearch: "ytsearch",
            }
        );

        const videoMetadatas = searchResults.stdout
            .trim()
            .split("\n")
            .map(JSON.parse);

        let bestVideo = null;
        let highestScore = -10000;

        videoMetadatas.forEach((video, index) => {
            let score = calculateScore(video, spotifyTrack);

            if (index === 0) {
                score += 15;
            }

            if (score > highestScore) {
                highestScore = score;
                bestVideo = video;
            }
        });

        if (!bestVideo) {
            console.error(`[Spotify] ERROR: No suitable YouTube video found for "${spotifyTrack.title}". Skipping.`);
            return;
        }

        console.log(`[Spotify] Best match for "${spotifyTrack.title}" is "${bestVideo.title}" with score ${highestScore}. Starting download.`);

        await ytdlp.exec(bestVideo.webpage_url, {
            extractAudio: true,
            audioFormat: "wav",
            output: outputPath,
        });

    } catch (e) {
        console.error(
            `[Spotify] ERROR: YouTube download failed for "${songData.title}". Attempting fallback.`, e
        );

        try {
            await ytdlp.exec(
                `ytsearch1:${searchQuery} Official Audio Music`,
                {
                    extractAudio: true,
                    audioFormat: "wav",
                    output: outputPath,
                    defaultSearch: "ytsearch",
                }
            );
        } catch (fallbackError) {
            console.error(`[Spotify] ERROR: Fallback download also failed for "${songData.title}".`, fallbackError);
            return;
        }
    }

    console.log(`[Spotify] Successfully downloaded "${title}" to "${outputPath}"`);
    const song = new Song(songData, outputPath);
    return song;
}

module.exports = {
    registerSpotifyHandlers,
};
